# 华为2016研发工程师编程题

---

[编程题] 删数
========

---

>有一个数组a[N]顺序存放0-N，要求没隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

输入描述:
=====

>每组数据为一行一个整数n(小于等于1000)，为数组成员数,如100，则对a[999]进行计算。


输出描述:
=====

>一行输出最后一个被删掉的数的原始下标位置。

输入例子:
=====

>8
输出例子:
=====

>6

``` C++
#include <iostream>
using namespace std;
int main()
{
    int n, p[1000];
  
    while (cin >> n)
    {
        for (int i = 0; i < n; i++)
            p[i] = 1;
 
        int index = 0, count = 0;
        for (int i = 0; count < n - 1 ; i++)
        {
            if (p[i % n] == 0)
                continue;
            if ((index + 1) % 3 == 0)
            {   
                p[i % n] = 0;
                count += 1;
            }
            index++;
        }
         
        for (int i = 0; i < n; i++)
        { 
            if (p[i])
            {cout << i << endl; break;}
        }
    }
    return 0;
}
```

[编程题]字符集合
=========

---
>输入一个字符串，求出该字符串包含的字符集合

输入描述:
=====

>每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。


输出描述:
=====

>每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。

输入例子:
=====

>abcqweracb

输出例子:
=====

>abcqwer

```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string p;
    while (cin >> p)
    {
        int set[128] = {0};
        for (string::iterator i = p.begin(); i != p.end(); i++)
        {
            int n = int(*i);
            if (!set[n])
                set[n] = 1;
            else
                *i = '*'; //重复字符替换为'*'
        }
        for (string::iterator i = p.begin(); i != p.end(); i++)
        {
            if (*i == '*')
                continue;
            else
                cout << *i;
        }
        cout << endl;
    }
    return 0;
}
```

[编程题]数独
=======
---

>数独是一个我们都非常熟悉的经典游戏，运用计算机我们可以很快地解开数独难题，现在有一些简单的数独题目，请编写一个程序求解。

输入描述:
=====

>输入9行，每行为空格隔开的9个数字，为0的地方就是需要填充的。


输出描述:
=====

>输出九行，每行九个空格隔开的数字，为解出的答案。

输入例子
====
>0 9 5 0 2 0 0 6 0
0 0 7 1 0 3 9 0 2
6 0 0 0 0 5 3 0 4
0 4 0 0 1 0 6 0 7
5 0 0 2 0 7 0 0 9
7 0 3 0 9 0 0 2 0
0 0 9 8 0 0 0 0 6
8 0 6 3 0 2 1 0 5
0 5 0 0 7 0 2 8 3

输出例子
====
>3 9 5 7 2 4 8 6 1
4 8 7 1 6 3 9 5 2
6 2 1 9 8 5 3 7 4
9 4 2 5 1 8 6 3 7
5 6 8 2 3 7 4 1 9
7 1 3 4 9 6 5 2 8
2 3 9 8 5 1 7 4 6
8 7 6 3 4 2 1 9 5
1 5 4 6 7 9 2 8 3
```cpp
#include <iostream>
using namespace std;

int num[9][9]; //放置九宫格数据
int row[9][10]; //若row[i][k]值为1，表示i行已经有数字k存在(i的取值范围[0~8],k的取值范围[1~9])
int column[9][10]; //若column[j][k]值为1，表示j列已经有数字k存在
int block[9][10]; //若block[b][k]值为1，表示b块已经有数字k存在

void init()
{
	for (int i = 0; i < 9; i++)
	{
		for (int j = 0; j < 9; j++)
		{
			cin >> num[i][j];
			int value = num[i][j];
			int b = (i / 3) * 3 + (j / 3);
			if (value != 0)
				row[i][value] = column[j][value] = block[b][value] = 1;
			else
				row[i][value] = column[j][value] = block[b][value] = 0;
		}
	}
}

void output()
{
	for (int i = 0; i < 9; i++)
	{
		for (int j = 0; j < 9; j++)
		{
			cout << num[i][j] << ' ';
		}
		cout << endl;
	}
}

void search(int n)
{
	if (n == 81) //边界条件
	{
		output();
		return;
	}
	int r = n / 9; //行号row
	int c = n % 9; //列号column
	int b = (r / 3) * 3 + (c / 3); //块号block

	if (num[r][c] != 0)
		search(n + 1);
	else{
		for (int k = 1; k <= 9; k++)
		{
			if (row[r][k] || column[c][k] || block[b][k]) //检查行、列和宫内是否冲突
				continue;
			else{ //给num[r][c]赋值k
				num[r][c] = k;
				row[r][k] = column[c][k] = block[b][k] = 1;
				search(n + 1); //回溯
				num[r][c] = 0;
				row[r][k] = column[c][k] = block[b][k] = 0;
			}
		}
	}
}

int main()
{	
	init();	
	search(0);
    return 0;
}
```




